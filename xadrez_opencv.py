# -*- coding: utf-8 -*-
"""xadrez_opencv.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ADubJROzMARNaI5QZsgtyJi1VxGZHg89
"""

!rm -rf xadrez_opencv

from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)

!unzip gdrive/My\ Drive/xadrez_opencv.zip

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

pecas = ['P', 'N', 'B', 'R', 'Q', 'K', 'p', 'n', 'b', 'r', 'q', 'k']
pecasP = [] # posicao das pecas
board = cv2.imread('xadrez_opencv/dataset/imagens/board_34.png')
cv2_imshow(board)

# Verificar tipo de interpolação para redimensionamento

if board.shape[0] > 600:
  board = cv2.resize(board, (600, 600), interpolation=cv2.INTER_AREA) # Diminuir
else:
  board = cv2.resize(board, (600, 600), interpolation=cv2.INTER_LINEAR) # Aumentar, outra opção ->  cv2.INTER_CUBIC

cv2_imshow(board)
board_gray = cv2.cvtColor(board, cv2.COLOR_BGR2GRAY)

"""## **Encontrar peças**"""

ret, board_th = cv2.threshold(board_gray, 70, 255, cv2.THRESH_BINARY) # destacar pecas
cv2_imshow(board_gray)
cv2_imshow(board_th)

"""## **Definir funções auxiliares**"""

def NMS(boxes): # Função para resolver o problema das bounding box que se sobrepoem
    if len(boxes) == 0:
        return []
    x1 = boxes[:, 0]  # x coordinate of the top-left corner
    y1 = boxes[:, 1]  # y coordinate of the top-left corner
    x2 = boxes[:, 2]  # x coordinate of the bottom-right corner
    y2 = boxes[:, 3]  # y coordinate of the bottom-right corner

    areas = (x2 - x1 + 1) * (y2 - y1 + 1)
    indices = np.arange(len(x1))

    for i,box in enumerate(boxes): 
        temp_indices = indices[indices!=i]
        xx1 = np.maximum(box[0], boxes[temp_indices,0])
        yy1 = np.maximum(box[1], boxes[temp_indices,1])
        xx2 = np.minimum(box[2], boxes[temp_indices,2])
        yy2 = np.minimum(box[3], boxes[temp_indices,3])

        w = np.maximum(0, xx2 - xx1 + 1)
        h = np.maximum(0, yy2 - yy1 + 1)

        overlap = (w * h) / areas[temp_indices]

        if np.any(overlap) > 0:
            indices = indices[indices != i]

    return boxes[indices].astype(int)

def get_boxes(res, w, h):
    threshold = 0.8
    (y1, x1) = np.where( res >= threshold)

    boxes = np.zeros((len(y1), 4))
    x2 = x1 + w
    y2 = y1 + h
    boxes[:, 0] = x1
    boxes[:, 1] = y1
    boxes[:, 2] = x2
    boxes[:, 3] = y2
    boxes = boxes.astype(int)
    return NMS(boxes)

def draw_boxes():
    for box in pecasP:
        x1, y1, x2, y2 = box[1]
        cv2.rectangle(board, (x1, y1), (x2, y2), (255, 0, 0), 2)

for peca in pecas:
    template = cv2.imread('xadrez_opencv/templates/' + peca + '.png', 0)
   # cv2_imshow(template)
    w, h = template.shape[::-1]
    res = cv2.matchTemplate(board_th, template, cv2.TM_CCOEFF_NORMED)
    boxes = get_boxes(res, w, h)
    pecasP.extend([(peca, box) for box in boxes])

draw_boxes()
cv2_imshow(board)

"""## **Gerar FEN**"""

tab = np.empty((8, 8), dtype=str)

for box in pecasP:
    x, y = box[1][:2]
    tab[y//75][x//75] = box[0]

fen = ''

for row in tab:
  k = 0
  for c in row:
    if c != '':
      if k!=0:
        fen += str(k)
        k = 0
      fen += c
    else:
      k += 1
  if k != 0:
    fen += str(k)
  fen += '/'

fen = fen[:-1]

"""## **Descobrir de quem é a vez**"""

turn = ' w'

# 153, 196
  
for peca in pecasP:
  x, y = peca[1][:2]
  pixel = board_gray[y][x]
  if (pixel == 153 or pixel == 196) and peca[0].isupper():
    turn = ' b'
    
fen += turn
fen

"""## **Abrir no navegador**"""

url = 'https://www.chess.com/analysis?fen=' + fen

if turn == ' b':
  url += '&flip=true'

from IPython.display import Javascript
display(Javascript('window.open("{url}");'.format(url=url)))

for peca in pecas:
    template = cv2.imread('xadrez_opencv/templates/' + peca + '.png', 0)
    cv2_imshow(template)